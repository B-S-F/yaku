/**
 * Copyright (c) 2023 by grow platform GmbH
 */

import { afterEach, describe, expect, it, vi } from 'vitest'
import { Authenticator } from '../../../src/auth/auth'
import { axiosInstance } from '../../../src/fetcher/common.fetcher'
import {
  getLibraryVulnerabilityDTOs,
  getVulnerabilityFixesDTOs,
} from '../../../src/fetcher/vulnerability.fetcher'
import { MendEnvironment } from '../../../src/model/mendEnvironment'
import { VulnerabilityDTO } from '../../../src/dto/vulnerability.dto'
import { VulnerabilityFixSummaryDTO } from '../../../src/dto/vulnerabilityFixSummary.dto'
import { envFixture } from '../fixtures/env'
import { HTTPResponseStatusCodes } from '../fixtures/httpResponseStatus'
import { FakeAuthenticator } from '../fixtures/fakeauth'
import {
  vulnerabilitiesData,
  vulnerabilitiesFixSummaryData,
} from '../fixtures/data'
import {
  vulnerabilitiesDTO,
  vulnerabilitiesFixSummaryDTO,
} from '../fixtures/dto'

describe('vulnerability.fetcher', () => {
  const env: MendEnvironment = envFixture

  afterEach(() => {
    vi.clearAllMocks()
    vi.restoreAllMocks()
  })

  it('should retrieve vulnerabilities when there is a single page response', async () => {
    const fakeAuth: FakeAuthenticator = new FakeAuthenticator(env)
    const spy = vi.spyOn(axiosInstance, 'request')
    spy.mockReturnValueOnce(
      Promise.resolve({
        data: {
          additionalData: {},
          retVal: vulnerabilitiesData,
        },
      })
    )
    spy.mockReturnValueOnce(
      Promise.resolve({
        data: {
          additionalData: {},
          retVal: [],
        },
      })
    )
    const libraryToken = 'library1-Uuid'
    const expected: VulnerabilityDTO[] = vulnerabilitiesDTO

    const result: VulnerabilityDTO[] = await getLibraryVulnerabilityDTOs(
      env.apiUrl,
      { projectToken: env.projectToken, libraryToken },
      fakeAuth as unknown as Authenticator
    )

    expect(result).toStrictEqual(expected)
  })

  it('should retrieve vulnerabilities when there is a multipage response', async () => {
    const fakeAuth: FakeAuthenticator = new FakeAuthenticator(env)
    const spy = vi.spyOn(axiosInstance, 'request')
    spy.mockReturnValueOnce(
      Promise.resolve({
        data: {
          additionalData: {},
          retVal: [vulnerabilitiesData[0]],
        },
      })
    )
    spy.mockReturnValueOnce(
      Promise.resolve({
        data: {
          additionalData: {},
          retVal: [vulnerabilitiesData[1]],
        },
      })
    )
    spy.mockReturnValueOnce(
      Promise.resolve({
        data: {
          additionalData: {},
          retVal: [],
        },
      })
    )
    const libraryToken = 'library1-Uuid'
    const expected: VulnerabilityDTO[] = vulnerabilitiesDTO

    const result: VulnerabilityDTO[] = await getLibraryVulnerabilityDTOs(
      env.apiUrl,
      { projectToken: env.projectToken, libraryToken },
      fakeAuth as unknown as Authenticator
    )

    expect(result).toStrictEqual(expected)
  })

  it('should throw an error when unexpected data is returned', async () => {
    const fakeAuth: FakeAuthenticator = new FakeAuthenticator(env)
    const spy = vi.spyOn(axiosInstance, 'request')
    spy.mockReturnValueOnce(Promise.resolve({ data: { not: 'expected' } }))
    const libraryToken = 'library1-Uuid'

    const result = getLibraryVulnerabilityDTOs(
      env.apiUrl,
      { projectToken: env.projectToken, libraryToken },
      fakeAuth as unknown as Authenticator
    )

    await expect(result).rejects.toThrowError('No expected values are returned')
  })

  it('should throw an error when request is not successful', async () => {
    const fakeAuth: FakeAuthenticator = new FakeAuthenticator(env)
    const spy = vi.spyOn(axiosInstance, 'request')
    spy.mockReturnValueOnce(
      Promise.reject({
        isAxiosError: true,
        request: {},
        message: 'Request Error Message',
      })
    )
    const libraryToken = 'library1-Uuid'

    const result = getLibraryVulnerabilityDTOs(
      env.apiUrl,
      { projectToken: env.projectToken, libraryToken },
      fakeAuth as unknown as Authenticator
    )

    await expect(result).rejects.toThrowError('Request Error Message')
  })

  it.each(HTTPResponseStatusCodes)(
    'should throw an error when response falls out of the 2xx range',
    async (httpStatus) => {
      const fakeAuth: FakeAuthenticator = new FakeAuthenticator(env)
      const spy = vi.spyOn(axiosInstance, 'request')
      spy.mockReturnValueOnce(
        Promise.reject({
          isAxiosError: true,
          response: {
            status: httpStatus.code,
            data: {},
            statusText: httpStatus.message,
          },
        })
      )
      const libraryToken = 'library1-Uuid'

      const result = getLibraryVulnerabilityDTOs(
        env.apiUrl,
        { projectToken: env.projectToken, libraryToken },
        fakeAuth as unknown as Authenticator
      )

      await expect(result).rejects.toThrowError(
        `Response status code ${httpStatus.code}: ${httpStatus.message}`
      )
    }
  )

  it.each(HTTPResponseStatusCodes)(
    'should throw an error when response falls out of the 2xx range and supportToken is provided',
    async (httpStatus) => {
      const fakeAuth: FakeAuthenticator = new FakeAuthenticator(env)
      const spy = vi.spyOn(axiosInstance, 'request')
      spy.mockReturnValueOnce(
        Promise.reject({
          isAxiosError: true,
          response: {
            data: {
              retVal: { errorMessage: httpStatus.message },
              supportToken: 'boo!',
            },
            statusText: '',
            status: httpStatus.code,
          },
        })
      )
      const libraryToken = 'library1-Uuid'

      const result = getLibraryVulnerabilityDTOs(
        env.apiUrl,
        { projectToken: env.projectToken, libraryToken },
        fakeAuth as unknown as Authenticator
      )

      await expect(result).rejects.toThrowError(
        `Response status code ${httpStatus.code}: ${httpStatus.message}`
      )
    }
  )

  it('should throw an error when it fails for unexpected reasons', async () => {
    const fakeAuth: FakeAuthenticator = new FakeAuthenticator(env)
    const spy = vi.spyOn(axiosInstance, 'request')
    spy.mockReturnValueOnce(Promise.reject())
    const libraryToken = 'library1-Uuid'

    const result = getLibraryVulnerabilityDTOs(
      env.apiUrl,
      { projectToken: env.projectToken, libraryToken },
      fakeAuth as unknown as Authenticator
    )

    await expect(result).rejects.toThrowError()
  })
})

describe('vulnerabilityFix.fetcher', () => {
  const env: MendEnvironment = envFixture

  afterEach(() => {
    vi.clearAllMocks()
    vi.restoreAllMocks()
  })

  it('should retrieve vulnerabilities fix', async () => {
    const fakeAuth: FakeAuthenticator = new FakeAuthenticator(env)
    const spy = vi.spyOn(axiosInstance, 'request')
    spy.mockReturnValueOnce(
      Promise.resolve({
        data: {
          additionalData: {},
          retVal: vulnerabilitiesFixSummaryData,
        },
      })
    )
    spy.mockReturnValueOnce(
      Promise.resolve({
        data: {
          additionalData: {},
          retVal: [],
        },
      })
    )
    const vulnerabilityId = 'vulnerability1-name'
    const expected: VulnerabilityFixSummaryDTO = vulnerabilitiesFixSummaryDTO

    const result: VulnerabilityFixSummaryDTO = await getVulnerabilityFixesDTOs(
      env.apiUrl,
      { vulnerabilityId: vulnerabilityId },
      fakeAuth as unknown as Authenticator
    )

    expect(result).toStrictEqual(expected)
  })

  it('should throw an error when unexpected data is returned', async () => {
    const fakeAuth: FakeAuthenticator = new FakeAuthenticator(env)
    const spy = vi.spyOn(axiosInstance, 'request')
    spy.mockReturnValueOnce(Promise.resolve({ data: { not: 'expected' } }))
    const libraryToken = 'library1-Uuid'

    const result = getLibraryVulnerabilityDTOs(
      env.apiUrl,
      { projectToken: env.projectToken, libraryToken },
      fakeAuth as unknown as Authenticator
    )

    await expect(result).rejects.toThrowError('No expected values are returned')

    spy.mockRestore()
  })

  it('should throw an error when request is not successful', async () => {
    const fakeAuth: FakeAuthenticator = new FakeAuthenticator(env)
    const spy = vi.spyOn(axiosInstance, 'request')
    spy.mockReturnValueOnce(
      Promise.reject({
        request: 'Request data',
        message: 'Request error message',
      })
    )
    const vulnerabilityId = 'vulnerability1-name'

    const result = getVulnerabilityFixesDTOs(
      env.apiUrl,
      { vulnerabilityId: vulnerabilityId },
      fakeAuth as unknown as Authenticator
    )

    await expect(result).rejects.toThrowError('Request error message')
  })

  it.each(HTTPResponseStatusCodes)(
    'should throw an error when response falls out of the 2xx range',
    async (httpStatus) => {
      const fakeAuth: FakeAuthenticator = new FakeAuthenticator(env)
      const spy = vi.spyOn(axiosInstance, 'request')
      spy.mockReturnValueOnce(
        Promise.reject({
          isAxiosError: true,
          response: {
            status: httpStatus.code,
            data: {},
            statusText: httpStatus.message,
          },
        })
      )
      const vulnerabilityId = 'vulnerability1-name'

      const result = getVulnerabilityFixesDTOs(
        env.apiUrl,
        { vulnerabilityId: vulnerabilityId },
        fakeAuth as unknown as Authenticator
      )

      await expect(result).rejects.toThrowError(
        `Response status code ${httpStatus.code}: ${httpStatus.message}`
      )
    }
  )

  it.each(HTTPResponseStatusCodes)(
    'should throw an error when response falls out of the 2xx range and supportToken is provided',
    async (httpStatus) => {
      const fakeAuth: FakeAuthenticator = new FakeAuthenticator(env)
      const spy = vi.spyOn(axiosInstance, 'request')
      spy.mockReturnValueOnce(
        Promise.reject({
          isAxiosError: true,
          response: {
            status: httpStatus.code,
            statusText: '',
            data: {
              retVal: { errorMessage: httpStatus.message },
              supportToken: 'boo!',
            },
          },
        })
      )
      const vulnerabilityId = 'vulnerability1-name'

      const result = getVulnerabilityFixesDTOs(
        env.apiUrl,
        { vulnerabilityId: vulnerabilityId },
        fakeAuth as unknown as Authenticator
      )

      await expect(result).rejects.toThrowError(
        `Response status code ${httpStatus.code}: ${httpStatus.message}`
      )
    }
  )

  it('should throw an error when it fails for unexpected reasons', async () => {
    const fakeAuth: FakeAuthenticator = new FakeAuthenticator(env)
    const spy = vi.spyOn(axiosInstance, 'request')
    spy.mockReturnValueOnce(Promise.reject())
    const vulnerabilityId = 'vulnerability1-name'

    const result = getVulnerabilityFixesDTOs(
      env.apiUrl,
      { vulnerabilityId: vulnerabilityId },
      fakeAuth as unknown as Authenticator
    )

    await expect(result).rejects.toThrowError()
  })
})
