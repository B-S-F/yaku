// SPDX-FileCopyrightText: 2024 grow platform GmbH
//
// SPDX-License-Identifier: MIT

import axios, { AxiosRequestConfig, AxiosResponse } from 'axios'
import { GetLogger } from '@B-S-F/autopilot-utils'
import { Authenticator } from '../auth/auth.js'
import { Login } from '../model/login.js'
import { VulnerabilityDTO } from '../dto/vulnerability.dto.js'
import { VulnerabilityFixSummaryDTO } from '../dto/vulnerabilityFixSummary.dto.js'
import { handleAxiosError, UnexpectedDataError } from './errors.fetcher.js'
import { VulnerabilityFix } from '../model/vulnerabilityFix.js'
import { axiosInstance } from './common.fetcher.js'

export const getLibraryVulnerabilityDTOs = async (
  apiUrl: string,
  config: { projectToken: string; libraryToken: string; pageSize?: number },
  auth: Authenticator
): Promise<VulnerabilityDTO[]> => {
  const url = `/api/v2.0/projects/${config.projectToken}/libraries/${config.libraryToken}/vulnerabilities`
  const login: Login = await auth.authenticate()
  const headers = {
    Accept: 'application/json',
    'Content-Type': 'application/json',
    Authorization: `Bearer ${login.jwtToken}`,
  }
  const requestConfig: AxiosRequestConfig = {
    url: url,
    method: 'get',
    baseURL: apiUrl,
    headers: headers,
    params: {
      page: 0,
      pageSize: config.pageSize ?? 100,
    },
  }
  const logger = GetLogger()

  let vulnerabilityDTOs: VulnerabilityDTO[] = []
  let retrievedItems: any[] = []

  do {
    try {
      const response: AxiosResponse = await axiosInstance.request(requestConfig)

      if (!response.data.retVal || !response.data.additionalData) {
        throw new UnexpectedDataError('No expected values are returned')
      }
      retrievedItems = response.data.retVal
      vulnerabilityDTOs = vulnerabilityDTOs.concat(
        retrievedItems.map(
          (item: any) =>
            new VulnerabilityDTO(
              item.name,
              item.type,
              item.description,
              item.score,
              item.severity,
              item.publishDate,
              item.modifiedDate,
              item.vulnerabilityScoring,
              item.references
            )
        )
      )
      requestConfig.params.page++
    } catch (error: any) {
      logger.error(
        `Getting Library Vulnerabilities from ${requestConfig.baseURL}${url} has failed`
      )
      if (axios.isAxiosError(error)) {
        handleAxiosError(error)
      }
      throw new Error(`Error ${error.message}`)
    }
  } while (retrievedItems.length > 0)

  return vulnerabilityDTOs
}

export const getVulnerabilityFixesDTOs = async (
  apiUrl: string,
  config: { vulnerabilityId: string; pageSize?: number },
  auth: Authenticator
): Promise<VulnerabilityFixSummaryDTO> => {
  const url = `/api/v2.0/vulnerabilities/${config.vulnerabilityId}/remediation`
  const login: Login = await auth.authenticate()
  const headers = {
    Accept: 'application/json',
    'Content-Type': 'application/json',
    Authorization: `Bearer ${login.jwtToken}`,
  }
  const requestConfig: AxiosRequestConfig = {
    url: url,
    method: 'get',
    baseURL: apiUrl,
    headers: headers,
  }
  const logger = GetLogger()

  let retrievedItems: any = []

  try {
    const response: AxiosResponse = await axiosInstance.request(requestConfig)

    if (!response.data.retVal) {
      throw new UnexpectedDataError('No expected values are returned')
    }
    let vulnerabilityFixSummaryDTOs: VulnerabilityFixSummaryDTO
    if (response.data.retVal.errorMessage) {
      vulnerabilityFixSummaryDTOs = new VulnerabilityFixSummaryDTO(
        config.vulnerabilityId,
        new VulnerabilityFix(
          0,
          config.vulnerabilityId,
          'N/A',
          'N/A',
          'N/A',
          '',
          'N/A',
          'This vulnerability does not have an available fix!',
          'N/A'
        ),
        [],
        0,
        0
      )
    } else {
      retrievedItems = response.data.retVal
      vulnerabilityFixSummaryDTOs = new VulnerabilityFixSummaryDTO(
        retrievedItems.vulnerability,
        new VulnerabilityFix(
          retrievedItems.topRankedFix.id,
          retrievedItems.topRankedFix.vulnerability,
          retrievedItems.topRankedFix.type,
          retrievedItems.topRankedFix.origin,
          retrievedItems.topRankedFix.url,
          retrievedItems.topRankedFix.fixResolution,
          retrievedItems.topRankedFix.date,
          retrievedItems.topRankedFix.message,
          retrievedItems.topRankedFix.extraData
        ),
        retrievedItems.allFixes,
        retrievedItems.totalUpVotes,
        retrievedItems.totalDownVotes
      )
    }
    return vulnerabilityFixSummaryDTOs
  } catch (error: any) {
    logger.error(
      `Getting Vulnerabilities Fixes from ${requestConfig.baseURL}${url} has failed`
    )
    if (axios.isAxiosError(error)) {
      handleAxiosError(error)
    }
    throw new Error(`Error ${error.message}`)
  }
}
