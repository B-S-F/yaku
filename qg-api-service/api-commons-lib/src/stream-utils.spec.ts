import { Readable } from 'stream'
import { decodeBufferToUTF8EncodedString, streamToString } from './stream-utils'

describe('Stream conversion to string', () => {
  it('should convert a multi array element Readable to the right string', async () => {
    const data = ['Chunk1', 'Chunk2', 'Chunk3']
    const stream = Readable.from(data)

    expect(await streamToString(stream)).toBe(data.join(''))
  })

  it('should create an empty string for an empty array', async () => {
    const stream = Readable.from([])

    expect(await streamToString(stream)).toBe('')
  })

  it('should handle an one element array correct', async () => {
    const data = 'Chunk'
    const stream = Readable.from(data)

    expect(await streamToString(stream)).toBe(data)
  })

  it('should throw error in case of a non-existing stream', async () => {
    await expect(() => streamToString(null)).rejects.toThrow()
  })
})

describe('Decoding of Buffer data', () => {
  const normalText =
    'metadata:\n:  version: v1\nheader:\n  name: Project name ${{ vars.VARS2 }} ${{ vars.VAR1 }}\n  version: ${{ env.USER }}\n'
  const excelData = `
504B030414000600080000002100A453
C5CF4E01000008040000130008025B43
6F6E74656E745F54797065735D2E786D
6C20A2040228A0000200000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
00000000000000000000000000000000
000000000000000000AC93CB4EC33010
45F748FC43E42D8ADDB2400835ED82C7
12BA281F60E24962D52F79DCD2FE3D13
F7B140A1156A37B162CFDC733D339ECC
36D6146B88A8BDABD8988F5801AEF64A
BBB6629F8BB7F2911598A453D2780715
DB02B2D9F4F666B2D806C082B21D56AC
4B293C098175075622F7011C9D343E5A
99E837B622C87A295B10F7A3D183A8BD
4BE052997A0D369DBC4023572615AF1B
DADE3989609015CFBBC09E55311982D1
B54CE454AC9DFA4529F7044E9939063B
1DF08E6C303148E84FFE06ECF33EA834
512B28E632A67769C986D818F1EDE3F2
CBFB253F2D32E0D2378DAE41F97A65A9
021C4304A9B00348D6F0BC722BB53BF8
3EC1CFC128F232BEB291FE7E59F88C8F
44FD0691BF975BC832678098B606F0DA
65CFA2A7C8D4AF79F401697223FC9F7E
18CD3EBB0C24043169380EE750938F44
9AFA8BAF0BFDBB52A006D822BFE3E90F
000000FFFF0300504B03041400060008
0000002100B5553023F40000004C0200
000B0008025F72656C732F2E72656C73
`
  const imageData = `
89504E470D0A1A0A0000000D49484452
000000220000001808060000009FA62F
09000000017352474200AECE1CE90000
0062655849664D4D002A000000080001
87690004000000010000001A00000000
0004928600070000001200000050A001
00030000000100010000A00200040000
000100000022A0030004000000010000
00180000000041534349490000005363
7265656E73686F74CFC405B4000001D4
`

  function hexStringToByteArray(hexString: string): Buffer {
    if (hexString.length % 2 !== 0) {
      throw new Error('Not a hex string, uneven number of characters')
    }
    const numBytes = hexString.length / 2
    const byteArray = new Uint8Array(numBytes)
    for (let i = 0; i < numBytes; i++) {
      byteArray[i] = parseInt(hexString.substring(i * 2, i * 2 + 2), 16)
    }
    return Buffer.from(byteArray)
  }

  it('should return an utf-8 string', () => {
    const result = decodeBufferToUTF8EncodedString(Buffer.from(normalText))

    expect(result).toEqual(normalText)
  })

  it('should return undefined for an utf-16 string', () => {
    const utf16buffer = Buffer.from(`\ufeff${normalText}`, 'utf16le')
    expect(decodeBufferToUTF8EncodedString(utf16buffer)).toBeUndefined()
  })

  it.each([excelData, imageData])(
    'should return undefined for binary data',
    (hex: string) => {
      const data = hexStringToByteArray(hex.replace(/\s/g, ''))

      expect(decodeBufferToUTF8EncodedString(data)).toBeUndefined()
    },
  )
})
